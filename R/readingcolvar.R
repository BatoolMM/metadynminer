#' Read COLVAR from Plumed
#'
#' `read.colvar` reads a colvar file generated by Plumed and returns a colvarfile object.
#' User can specify which colums contain collective variables and bias potetnial.
#'
#' @param file COLVAR file from Plumed.
#' @param timec 1 index of the column containing time.
#' @param cvsc 2:3 numerical vector of indexes of columns containing collective variables.
#' @param biasc 4 index of the column containing the bias potential (NULL for no bias).
#' @return colvarfile object.
#'
#' @export
#' @examples
#' l1<-" 0.000000 -1.777407 2.448895 0.000000"
#' l2<-" 0.200000 -1.200988 2.527485 0.000000"
#' l3<-" 0.400000 -1.619547 2.940819 0.000000"
#' l4<-" 0.600000 -2.158700 -2.619621 0.000000"
#' l5<-" 0.800000 -2.166794 2.961958 0.000000"
#' l6<-" 1.000000 -1.408921 2.808417 0.000000"
#' l7<-" 1.200000 -2.143911 2.381913 0.018102"
#' l8<-" 1.400000 -1.970727 2.993245 0.143235"
#' l9<-" 1.600000 -2.396591 2.939432 0.004027"
#' l10<-" 1.800000 -2.262091 2.837568 0.017447"
#' snaps<-c(l1,l2,l3,l4,l5,l6,l7,l8,l9,l10)
#' tf <- tempfile()
#' writeLines(snaps, tf)
#' read.colvar(tf, timec=1, cvsc=2:3, biasc=4)
read.colvar<-function(file="COLVAR", timesc=1, cvsc=2:3, biasc=4) {
  colvarf<-read.table(file, header=F, comment.char="#")
  if(sum(ncol(colvarf)<cvsc)>0) {
    stop("Error: Number of columns in COLVAR file smaller than CV indexes")
  }
  if(is.null(biasc)) {
    bias = NULL
  } else {
    if(ncol(colvarf)>biasc) {
      stop("Error: Number of columns in COLVAR file smaller than bias index")
    }
    bias=colvarf[,biasc]
  }
  if(is.null(timesc)) {
    times=NULL
  } else {
    if(ncol(colvarf)<timesc) {
      stop("Error: Number of columns in COLVAR file smaller than time index")
    }
    times=colvarf[,timesc]
  }
  colvars<-list(filename=file, times=times, ncvs=length(cvsc), cvs=colvarf[,cvsc], bias=bias)
  class(colvars) <- "colvarfile"
  cat("COLVAR file read\n")
  return(colvars)
}

#' Print colvarfile
#'
#' `print.colvarfile` prints dimensionality and size of a colvarfile object.
#'
#' @param x colvarfile object.
#' @param ... further arguments passed to or from other methods.
#'
#' @export
#' @examples
#' acealanmeCVs
print.colvarfile<-function(x,...) {
  cat("collective variable record ")
  cat(x$filename)
  cat(" containing ")
  cat(x$ncvs)
  cat(" collective variables and ")
  if(x$ncvs>1) {
    cat(nrow(x$cvs))
  } else {
    cat(length(x$cvs))
  }
  cat(" records\n")
}

#' Print summary for colvarfile
#'
#' `summary.colvarfile` prints dimensionality, size and minima/maxima of
#; collective variables and bias in a colvarfile object.
#'
#' @param x colvarfile object.
#' @param ... further arguments passed to or from other methods.
#'
#' @export
#' @examples
#' summary(acealanmeCVs)
summary.colvarfile<-function(x,...) {
  cat("collective variable record ")
  cat(x$filename)
  cat(" containing ")
  cat(x$ncvs)
  cat(" collective variables and ")
  if(x$ncvs>1) {
    cat(nrow(x$cvs))
  } else {
    cat(length(x$cvs))
  }
  cat(" records\n")
  if(!is.null(x$times)) {
    cat("Time from ")
    cat(min(x$times))
    cat(" to ")
    cat(max(x$times))
    cat("\n")
  } else {
    cat("No times\n")
  }
  for(i in 1:x$ncvs) {
    cat("CV")
    cat(i)
    cat(" from ")
    if(x$ncvs>1) {
      cat(min(x$cvs[,i]))
    } else {
      cat(min(x$cvs))
    }
    cat(" to ")
    if(x$ncvs>1) {
      cat(max(x$cvs[,i]))
    } else {
      cat(max(x$cvs))
    }
    cat("\n")
  }
  if(!is.null(x$bias)) {
   cat("Bias from ")
    cat(min(x$bias))
    cat(" to ")
    cat(max(x$bias))
    cat("\n")
  } else {
    cat("No bias\n")
  }
}

#' Print first n lines of colvarfile
#'
#' `head.colvarfile` prints first n lines of a colvarfile object.
#'
#' @param x colvarfile object.
#' @param n number of lines (default 10).
#' @param ... further arguments passed to or from other methods.
#'
#' @export
#' @examples
#' head(acealanmeCVs)
head.colvarfile<-function(x, n=10,...) {
  cvnames <- c()
  for(i in 1:x$ncvs) {
    cvnames <- c(cvnames, paste("CV", toString(i), sep=""))
  }
  if(is.null(x$times) & is.null(x$bias)) {
    colnames <- c(cvnames)
    if(x$ncvs>1) {
      outdf <- data.frame(x$cvs[1:n,])
    } else {
      outdf <- data.frame(x$cvs[1:n])
    }
  }
  if(is.null(x$times) & !is.null(x$bias)) {
    colnames <- c(cvnames, "bias")
    if(x$ncvs>1) {
      outdf <- data.frame(x$cvs[1:n,], x$bias[1:n])
    } else {
      outdf <- data.frame(x$cvs[1:n], x$bias[1:n])
    }
  }
  if(!is.null(x$times) & is.null(x$bias)) {
    colnames <- c("time", cvnames)
    if(x$ncvs>1) {
      outdf <- data.frame(x$times[1:n], x$cvs[1:n,])
    } else {
      outdf <- data.frame(x$times[1:n], x$cvs[1:n])
    }
  }
  if(!is.null(x$times) & !is.null(x$bias)) {
    colnames <- c("time", cvnames, "bias")
    if(x$ncvs>1) {
      outdf <- data.frame(x$times[1:n], x$cvs[1:n,], x$bias[1:n])
    } else {
      outdf <- data.frame(x$times[1:n], x$cvs[1:n], x$bias[1:n])
    }
  }
  names(outdf) <- colnames
  return(outdf)
}

#' Print last n lines of colvarfile
#'
#' `tail.colvarfile` prints last n lines of a colvarfile object.
#'
#' @param x colvarfile object.
#' @param n number of lines (default 10).
#' @param ... further arguments passed to or from other methods.
#'
#' @export
#' @examples
#' tail(acealanmeCVs)
tail.colvarfile<-function(x, n=10,...) {
  if(x$ncvs>1) {
    nlines <- nrow(x$cvs)
  } else {
    nlines <- length(x$cvs)
  }
  cvnames <- c()
  for(i in 1:x$ncvs) {
    cvnames <- c(cvnames, paste("CV", toString(i), sep=""))
  }
  if(is.null(x$times) & is.null(x$bias)) {
    colnames <- c(cvnames)
    if(x$ncvs>1) {
      outdf <- data.frame(x$cvs[(nlines-n):nlines,])
    } else {
      outdf <- data.frame(x$cvs[(nlines-n):nlines])
    }
  }
  if(is.null(x$times) & !is.null(x$bias)) {
    colnames <- c(cvnames, "bias")
    if(x$ncvs>1) {
      outdf <- data.frame(x$cvs[(nlines-n):nlines,], x$bias[(nlines-n):nlines])
    } else {
      outdf <- data.frame(x$cvs[(nlines-n):nlines], x$bias[(nlines-n):nlines])
    }
  }
  if(!is.null(x$times) & is.null(x$bias)) {
    colnames <- c("time", cvnames)
    if(x$ncvs>1) {
      outdf <- data.frame(x$times[(nlines-n):nlines], x$cvs[(nlines-n):nlines,])
    } else {
      outdf <- data.frame(x$times[(nlines-n):nlines], x$cvs[(nlines-n):nlines])
    }
  }
  if(!is.null(x$times) & !is.null(x$bias)) {
    colnames <- c("time", cvnames, "bias")
    if(x$ncvs>1) {
      outdf <- data.frame(x$times[(nlines-n):nlines], x$cvs[(nlines-n):nlines,],
                          x$bias[(nlines-n):nlines])
    } else {
      outdf <- data.frame(x$times[(nlines-n):nlines], x$cvs[(nlines-n):nlines],
                          x$bias[(nlines-n):nlines])
    }
  }
  names(outdf) <- colnames
  return(outdf)
}

#' @export
`+.colvarfile`<-function(cv1, cv2) {
  cat("Warning: File name of only the firs colvar file will be retained\n")
  if(cv1$ncvs!=cv2$ncvs) {
    stop("Error: You can sum only colvar files of same dimension")
  }
  cat("Warning: Times will be concatenated, not prolonged\n")
  colvars<-list(filename=cv1$file, times=c(cv1$times, cv2$times), ncvs=cv1$ncvs,
                cvs=rbind(cv1$cvs,cv2$cvs), bias=c(cv1$bias,cv2$bias))
  class(colvars) <- "colvarfile"
  return(colvars)
}

#' Plot colvarfile object
#'
#' `plot.colvarfile` plots colvarfile object. For a colvarfile with one collective variable it plots its evolution.
#' For a colvarfile with two collective variables it plots CV1 vs. CV2. For a colvarfile with more collective
#' variables it does not work, but you can still use $times and $cvs with default 'plot' function.
#'
#' @param x colvarfile object.
#' @param ignoretime time in the first column of the colvarfile will be ignored.
#' @param main an overall title for the plot: see 'title'.
#' @param sub a sub title for the plot: see 'title'.
#' @param xlab a title for the x axis: see 'title'.
#' @param ylab a title for the y axis: see 'title'.
#' @param asp the y/x aspect ratio, see 'plot.window'.
#' @param pch plotting 'character', i.e., symbol to use. See 'points'.
#' @param col color code or name, see 'par'.
#' @param bg background (fill) color for the open plot symbols given by
#'        'pch = 21:25'.
#' @param cex character (or symbol) expansion: a numerical vector. This
#'        works as a multiple of 'par("cex")'.
#' @param lwd line width for drawing symbols see 'par'.
#' @param xlim numeric vector of length 2, giving the x coordinates range.
#' @param ylim numeric vector of length 2, giving the y coordinates range.
#' @param axes a logical value indicating whether both axes should be drawn
#'        on the plot.
#' @param ... further arguments passed to or from other methods.
#'
#' @export
#' @examples
#' plot(acealanmeCVs)
plot.colvarfile<-function(x, ignoretime=FALSE,
                          xlab=NULL, ylab=NULL,
                          xlim=NULL, ylim=NULL,
                          main=NULL, sub=NULL,
                          pch=1, col="black", bg="red", cex=1,
                          asp=NULL, lwd=1, axes=TRUE,...) {
  cvfile <-x
  xlims<-NULL
  ylims<-NULL
  if(!is.null(xlim)) {xlims<-xlim}
  if(!is.null(ylim)) {ylims<-ylim}
  if(cvfile$ncvs==1) {
    if(is.null(xlab)) xlab="time"
    if(is.null(ylab)) ylab="CV"
    if(is.null(cvfile$times)) {
      if(cvfile$ncvs==1) {
        times <- 1:length(cvfile$cvs)
      } else {
        times <- 1:nrow(cvfile$cvs)
      }
    } else {
      times <- cvfile$times
    }
    if(ignoretime) {
      plot(seq(from=times[1],by=times[2],length.out=length(times)),
           cvfile$cvs, type="l",
           xlab=xlab, ylab=ylab,
           main=main, sub=sub,
           xlim=xlims, ylim=ylims,
           col=col, cex=cex, lwd=lwd,
           asp=asp, axes=axes)
    } else {
      plot(times, cvfile$cvs, type="l",
           xlab=xlab, ylab=ylab,
           main=main, sub=sub,
           xlim=xlims, ylim=ylims,
           col=col, cex=cex, lwd=lwd,
           asp=asp, axes=axes)
    }
  }
  if(cvfile$ncvs==2) {
    if(is.null(xlab)) xlab="CV1"
    if(is.null(ylab)) ylab="CV2"
    plot(cvfile$cvs[,1], cvfile$cvs[,2], type="p",
         xlab=xlab, ylab=ylab,
         main=main, sub=sub,
         xlim=xlims, ylim=ylims,
         pch=pch, col=col, bg=bg, cex=cex, lwd=lwd,
         asp=asp, axes=axes)
  }
  if(cvfile$ncvs>2) {
    cat("plot.colvarfile does not work for a colvarfile with more collective\n")
    cat("variables than 2, but you can still use $times and $cvs with default\n")
    cat("plot function.\n")
  }
}

#' Plot points for colvarfile object
#'
#' `points.colvarfile` plots points for colvarfile object. For a colvarfile with one
#' collective variable it plots its evolution. For a colvarfile with two collective
#' variables it plots CV1 vs. CV2. For a colvarfile with more collective
#' variables it does not work, but you can still use $times and $cvs with default
#' 'plot' and 'points' function.
#'
#' @param x colvarfile object.
#' @param ignoretime time in the first column of the colvarfile will be ignored.
#' @param pch plotting 'character', i.e., symbol to use. See 'points'.
#' @param col color code or name, see 'par'.
#' @param bg background (fill) color for the open plot symbols given by
#'        'pch = 21:25'.
#' @param cex character (or symbol) expansion: a numerical vector. This
#'        works as a multiple of 'par("cex")'.
#' @param lwd line width for drawing symbols see 'par'.
#' @param ... further arguments passed to or from other methods.
#'
#' @export
#' @examples
#' plot(acealanmeCVs)
#' points(acealanmeCVs, col="red")
points.colvarfile<-function(x, ignoretime=FALSE,
                           pch=1, col="black", bg="red", cex=1,
                           lwd=1, ...) {
  cvfile <-x
  if(cvfile$ncvs==1) {
    if(is.null(cvfile$times)) {
      if(cvfile$ncvs==1) {
        times <- 1:length(cvfile$cvs)
      } else {
        times <- 1:nrow(cvfile$cvs)
      }
    } else {
      times <- cvfile$times
    }
    if(ignoretime) {
      points(seq(from=times[1],by=times[2],length.out=length(times)),
             cvfile$cvs, col=col, cex=cex, lwd=lwd)
    } else {
      points(times, cvfile$cvs, col=col, cex=cex, lwd=lwd)
    }
  }
  if(cvfile$ncvs==2) {
    points(cvfile$cvs[,1], cvfile$cvs[,2],
           pch=pch, col=col, bg=bg, cex=cex, lwd=lwd)
  }
  if(cvfile$ncvs>2) {
    cat("points.colvarfile does not work for a colvarfile with more collective\n")
    cat("variables than 2, but you can still use $times and $cvs with default\n")
    cat("plot/points function.\n")
  }
}

#' Plot lines for colvarfile object
#'
#' `lines.colvarfile` plots lines for colvarfile object. For a colvarfile with one
#' collective variable it plots its evolution. For a colvarfile with two collective
#' variables it plots CV1 vs. CV2. For a colvarfile with more collective
#' variables it does not work, but you can still use $times and $cvs with default
#' 'plot' and 'lines' function.
#'
#' @param x colvarfile object.
#' @param ignoretime time in the first column of the colvarfile will be ignored.
#' @param col color code or name, see 'par'.
#' @param lwd line width for drawing symbols see 'par'.
#' @param ... further arguments passed to or from other methods.
#'
#' @export
#' @examples
#' plot(acealanmeCVs)
#' lines(acealanmeCVs, col="red")
lines.colvarfile<-function(x, ignoretime=FALSE,
                           lwd=1, col="black",...) {
  cvfile <-x
  if(cvfile$ncvs==1) {
    if(is.null(cvfile$times)) {
      if(cvfile$ncvs==1) {
        times <- 1:length(cvfile$cvs)
      } else {
        times <- 1:nrow(cvfile$cvs)
      }
    } else {
      times <- cvfile$times
    }
    if(ignoretime) {
      lines(seq(from=times[1],by=times[2],length.out=length(times)),
            cvfile$cvs, col=col, lwd=lwd)
    } else {
      lines(times, cvfile$cvs, col=col, lwd=lwd)
    }
  }
  if(cvfile$ncvs==2) {
    lines(cvfile$cvs[,1], cvfile$cvs[,2],
          col=col, lwd=lwd)
  }
  if(cvfile$ncvs>2) {
    cat("lines.colvarfile does not work for a colvarfile with more collective\n")
    cat("variables than 2, but you can still use $times and $cvs with default\n")
    cat("plot/lines function.\n")
  }
}

#' Plot evolution of bias potential in colvarfile object
#'
#' `plotbias` plots evolution of bias potential in colvarfile.
#'
#' @param colvar colvarfile object.
#' @param ignoretime time in the first column of the HILLS file will be ignored.
#' @param main an overall title for the plot: see 'title'.
#' @param sub a sub title for the plot: see 'title'.
#' @param xlab a title for the x axis: see 'title'.
#' @param ylab a title for the y axis: see 'title'.
#' @param asp the y/x aspect ratio, see 'plot.window'.
#' @param col color code or name, see 'par'.
#' @param lwd line width for drawing symbols see 'par'.
#' @param xlim numeric vector of length 2, giving the x coordinates range.
#' @param ylim numeric vector of length 2, giving the y coordinates range.
#' @param axes a logical value indicating whether both axes should be drawn
#'        on the plot.
#'
#' @export
#' @examples
#' plotbias(acealanmeCVs)
plotbias<-function(cvfile, ignoretime=FALSE,
                   xlab=NULL, ylab=NULL,
                   xlim=NULL, ylim=NULL,
                   main=NULL, sub=NULL,
                   col="black", asp=NULL, lwd=1, axes=TRUE) {
  if(class(cvfile)=="colvarfile") {
    if(cvfile$bias==NULL) {
      stop("Error: Input colvarfile does not contain any bias potential")
    }
    if(is.null(xlab)) xlab="time"
    if(is.null(ylab)) ylab="bias potential"
    if(is.null(cvfile$times)) {
      if(cvfile$ncvs==1) {
        times <- 1:length(cvfile$cvs)
      } else {
        times <- 1:nrow(cvfile$cvs)
      }
    } else {
      times <- cvfile$times
    }
    if(ignoretime) {
      plot(seq(from=times[1],by=times[2],length.out=length(times)),
           cvfile$bias, type="l",
           xlab=xlab, ylab=ylab,
           main=main, sub=sub,
           col=col, lwd=lwd,
           asp=asp, axes=axes)
    } else {
      plot(times, cvfile$bias,
           xlab=xlab, ylab=ylab,
           main=main, sub=sub,
           col=col, lwd=lwd,
           asp=asp, axes=axes)
    }
  } else {
    stop("Error: Function plotbias requires object colvarfile as an input")
  }
}

